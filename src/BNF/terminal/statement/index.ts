import { ATOM, CONCAT, OPTIONAL, OR, STAR, WORD } from "../..";
import { CONST_DECLARATOR, DECLARATOR, LET_DECLARATOR } from "../declarator";
import {
  ARRAY_ACCESS_EXPRESSION,
  CLOSING_CURLY,
  CLOSING_PARENTHESIS,
  EXPRESSION,
  OPENING_CURLY,
  OPENING_PARENTHESIS,
  UNARY_EXPRESSION,
} from "./expression";
import { CONST_IDENTIFIER, IDENTIFIER } from "../identifier";
import {
  ASSIGNMENT_OPERATOR,
  ASSIGNMENT_OPERATORS,
} from "../operator/assignment";
import { SEMICOLON, UNDERSCORE } from "../specialCharacter";
import { VALUE } from "../value";
import { NON_EMPTY_WHITESPACE, WHITESPACE } from "../whitespace";
import {
  CATCH_KEYWORD,
  CLASS_EXTENDS_KEYWORD,
  CLASS_KEYWORD,
  DATATYPE_SPECIFIER,
  FINALLY_KEYWORD,
  FUNCTION_KEYWORD,
  IF_STATEMENT_KEYWORD_ELSE,
  IF_STATEMENT_KEYWORD_ELSE_IF,
  IF_STATEMENT_KEYWORD_IF,
  LOOPING_CONTROL_KEYWORD,
  LOOPING_KEYWORD_DO,
  LOOPING_KEYWORD_FOR,
  LOOPING_KEYWORD_WHILE,
  NEW_OBJECT_KEYWORD,
  RAISE_KEYWORD,
  RETURN_KEYWORD,
  SWITCH_KEYWORD_CASE,
  SWITCH_KEYWORD_DEFAULT,
  SWITCH_KEYWORD_SWITCH,
  TRY_KEYWORD,
} from "../keyword";
import { COMMENT } from "../comment";
import { ALPHABET } from "../alphabet";
import { DIGIT } from "../digit";
import { Token } from "../tokenType";

let _STATEMENTS = OR().name(Token.STATEMENTS);

const LIST_OF_STATEMENTS = STAR(
  CONCAT(WHITESPACE, _STATEMENTS, WHITESPACE)
).name(Token.SWISS);

export const CODE_BLOCK = CONCAT(
  OPENING_CURLY,
  LIST_OF_STATEMENTS,
  CLOSING_CURLY
).name(Token.CODE_BLOCK);

export const DATA_TYPE = CONCAT(
  OR(ALPHABET, UNDERSCORE).name(Token.NO_DIGIT_PREFIX),
  STAR(OR(ALPHABET, UNDERSCORE, DIGIT).name(Token.NO_PREFIX_RESTRICTION)).name(
    "ANY_COMBINATION"
  )
)
  .name(Token.DATA_TYPE)
  .token();

export const CONST_DECLARATION_STATEMENT = CONCAT(
  CONST_DECLARATOR,
  NON_EMPTY_WHITESPACE,
  OR(
    CONCAT(DATATYPE_SPECIFIER, NON_EMPTY_WHITESPACE, CONST_IDENTIFIER),
    CONCAT(DATA_TYPE, NON_EMPTY_WHITESPACE, CONST_IDENTIFIER),
    CONST_IDENTIFIER
  ),
  WHITESPACE,
  OPTIONAL(CONCAT(ASSIGNMENT_OPERATOR, WHITESPACE, EXPRESSION))
).name(Token.CONST_DECLARATION_STATEMENT);

export const LET_DECLARATION_STATEMENT = CONCAT(
  LET_DECLARATOR,
  NON_EMPTY_WHITESPACE,
  OR(
    CONCAT(DATATYPE_SPECIFIER, NON_EMPTY_WHITESPACE, IDENTIFIER),
    CONCAT(DATA_TYPE, NON_EMPTY_WHITESPACE, IDENTIFIER),
    IDENTIFIER
  ),
  WHITESPACE,
  OPTIONAL(CONCAT(ASSIGNMENT_OPERATOR, WHITESPACE, EXPRESSION))
).name(Token.LET_DECLARATION_STATEMENT);

export const DECLARATION_STATEMENT = OR(
  CONST_DECLARATION_STATEMENT,
  LET_DECLARATION_STATEMENT
).name(Token.DECLARATION_STATEMENT);

export const ASSIGNMENT_STATEMENT = OR(
  CONCAT(
    OR(IDENTIFIER, ARRAY_ACCESS_EXPRESSION),
    WHITESPACE,
    ASSIGNMENT_OPERATORS,
    WHITESPACE,
    EXPRESSION
  ),
  UNARY_EXPRESSION
).name(Token.ASSIGNMENT_STATEMENT);

export const ELSE_IF_STATEMENT = CONCAT(
  IF_STATEMENT_KEYWORD_ELSE_IF,
  WHITESPACE,
  OPENING_PARENTHESIS,
  WHITESPACE,
  EXPRESSION,
  WHITESPACE,
  CLOSING_PARENTHESIS,
  WHITESPACE,
  CODE_BLOCK
).name(Token.ELSE_IF_STATEMENT);

export const ELSE_STATEMENT = CONCAT(
  IF_STATEMENT_KEYWORD_ELSE,
  WHITESPACE,
  CODE_BLOCK
).name(Token.ELSE_STATEMENT);

export const WHILE_STATEMENT = CONCAT(
  LOOPING_KEYWORD_WHILE,
  WHITESPACE,
  OPENING_PARENTHESIS,
  WHITESPACE,
  EXPRESSION,
  WHITESPACE,
  CLOSING_PARENTHESIS,
  WHITESPACE,
  CODE_BLOCK
).name(Token.WHILE_STATEMENT);

export const IF_STATEMENT = CONCAT(
  IF_STATEMENT_KEYWORD_IF,
  WHITESPACE,
  OPENING_PARENTHESIS,
  WHITESPACE,
  EXPRESSION,
  WHITESPACE,
  CLOSING_PARENTHESIS,
  WHITESPACE,
  CODE_BLOCK,
  OPTIONAL(STAR(CONCAT(WHITESPACE, ELSE_IF_STATEMENT, WHITESPACE))),
  OPTIONAL(CONCAT(WHITESPACE, ELSE_STATEMENT, WHITESPACE))
).name(Token.IF_STATEMENT);

export const DO_WHILE_STATEMENT = CONCAT(
  LOOPING_KEYWORD_DO,
  WHITESPACE,
  CODE_BLOCK,
  WHITESPACE,
  LOOPING_KEYWORD_WHILE,
  WHITESPACE,
  OPENING_PARENTHESIS,
  WHITESPACE,
  EXPRESSION,
  WHITESPACE,
  CLOSING_PARENTHESIS,
  WHITESPACE,
  SEMICOLON
).name(Token.DO_WHILE_STATEMENT);

const TRUE_STATEMENTS = OR(
  DECLARATION_STATEMENT,
  ASSIGNMENT_STATEMENT,
  EXPRESSION
);

export const FOR_STATEMENT = CONCAT(
  LOOPING_KEYWORD_FOR,
  WHITESPACE,
  OPENING_PARENTHESIS,
  WHITESPACE,
  TRUE_STATEMENTS,
  WHITESPACE,
  SEMICOLON,
  WHITESPACE,
  TRUE_STATEMENTS,
  WHITESPACE,
  SEMICOLON,
  WHITESPACE,
  TRUE_STATEMENTS,
  WHITESPACE,
  CLOSING_PARENTHESIS,
  WHITESPACE,
  CODE_BLOCK
).name(Token.FOR_STATEMENT);

export const FUNCTION_STATEMENT = CONCAT(
  FUNCTION_KEYWORD,
  NON_EMPTY_WHITESPACE,
  IDENTIFIER,
  WHITESPACE,
  OPENING_PARENTHESIS,
  WHITESPACE,
  STAR(
    CONCAT(
      IDENTIFIER,
      WHITESPACE,
      ATOM(",").name(Token.PARAMETER_SEPARATOR),
      WHITESPACE
    )
  ).name(Token.REST_PARAMETER),
  OPTIONAL(IDENTIFIER).name(Token.PARAMETER).token(),
  WHITESPACE,
  CLOSING_PARENTHESIS,
  WHITESPACE,
  CODE_BLOCK
).name(Token.FUNCTION_STATEMENT);

export const FINALLY_STATEMENT = CONCAT(
  FINALLY_KEYWORD,
  WHITESPACE,
  CODE_BLOCK
).name(Token.FINALLY_STATEMENT);

export const CATCH_STATEMENT = CONCAT(
  CATCH_KEYWORD,
  WHITESPACE,
  OPTIONAL(
    CONCAT(
      OPENING_PARENTHESIS,
      WHITESPACE,
      OPTIONAL(IDENTIFIER),
      WHITESPACE,
      CLOSING_PARENTHESIS
    )
  ),
  WHITESPACE,
  CODE_BLOCK
).name(Token.CATCH_STATEMENT);

export const TRY_STATEMENT = CONCAT(
  TRY_KEYWORD,
  WHITESPACE,
  CODE_BLOCK,
  OPTIONAL(CONCAT(WHITESPACE, CATCH_STATEMENT, WHITESPACE)),
  OPTIONAL(CONCAT(WHITESPACE, FINALLY_STATEMENT, WHITESPACE))
).name(Token.TRY_STATEMENT);

export const RAISE_STATEMENT = CONCAT(
  RAISE_KEYWORD,
  NON_EMPTY_WHITESPACE,
  EXPRESSION,
  SEMICOLON
).name(Token.RAISE_STATEMENT);

export const CASE_STATEMENT = CONCAT(
  SWITCH_KEYWORD_CASE,
  WHITESPACE,
  EXPRESSION,
  WHITESPACE,
  CODE_BLOCK
).name(Token.CASE_STATEMENT);

export const DEFAULT_CASE_STATEMENT = CONCAT(
  SWITCH_KEYWORD_DEFAULT,
  WHITESPACE,
  CODE_BLOCK
).name(Token.DEFAULT_CASE_STATEMENT);

export const SWITCH_STATEMENT = CONCAT(
  SWITCH_KEYWORD_SWITCH,
  WHITESPACE,
  CONCAT(
    OPENING_PARENTHESIS,
    WHITESPACE,
    EXPRESSION,
    WHITESPACE,
    CLOSING_PARENTHESIS
  ),
  WHITESPACE,
  CONCAT(
    OPENING_CURLY,
    WHITESPACE,
    STAR(CONCAT(CASE_STATEMENT, WHITESPACE)),
    OPTIONAL(DEFAULT_CASE_STATEMENT),
    WHITESPACE,
    CLOSING_CURLY
  )
).name(Token.SWITCH_STATEMENT);

export const RETURN_STATEMENT = CONCAT(
  RETURN_KEYWORD,
  WHITESPACE,
  OPTIONAL(EXPRESSION),
  SEMICOLON
).name(Token.RETURN_STATEMENT);

export const ITERATIVE_CONTROL_STATEMENT = CONCAT(
  LOOPING_CONTROL_KEYWORD,
  WHITESPACE,
  SEMICOLON
).name(Token.ITERATIVE_CONTROL_STATEMENT);

export const CLASS_INSTANCE_VARIABLE = CONCAT(
  OR(
    CONCAT(DATATYPE_SPECIFIER, NON_EMPTY_WHITESPACE, IDENTIFIER),
    CONCAT(DATA_TYPE, NON_EMPTY_WHITESPACE, IDENTIFIER),
    IDENTIFIER
  ),
  WHITESPACE,
  OPTIONAL(CONCAT(ASSIGNMENT_OPERATOR, WHITESPACE, EXPRESSION)),
  SEMICOLON
).name(Token.CLASS_INSTANCE_VARIABLE);

export const CLASS_METHOD = CONCAT(
  IDENTIFIER,
  WHITESPACE,
  OPENING_PARENTHESIS,
  STAR(
    CONCAT(
      IDENTIFIER,
      WHITESPACE,
      ATOM(",").name(Token.PARAMETER_SEPARATOR),
      WHITESPACE
    )
  ).name(Token.REST_PARAMETER),
  OPTIONAL(IDENTIFIER).name(Token.PARAMETER).token(),
  CLOSING_PARENTHESIS,
  WHITESPACE,
  CODE_BLOCK
).name(Token.CLASS_METHOD);

export const CLASS_CODE_BLOCK = CONCAT(
  OPENING_CURLY,
  WHITESPACE,
  STAR(
    CONCAT(
      CONCAT(
        OR(CLASS_METHOD, CLASS_INSTANCE_VARIABLE),
        OPTIONAL(CONCAT(WHITESPACE, COMMENT))
      ),
      WHITESPACE
    )
  ),
  WHITESPACE,
  CLOSING_CURLY
).name(Token.CLASS_CODE_BLOCK);

export const CLASS_DECLARATION = CONCAT(
  CLASS_KEYWORD,
  NON_EMPTY_WHITESPACE,
  IDENTIFIER,
  NON_EMPTY_WHITESPACE,
  OPTIONAL(
    CONCAT(
      CLASS_EXTENDS_KEYWORD,
      NON_EMPTY_WHITESPACE,
      IDENTIFIER,
      WHITESPACE
    ).name(Token.CLASS_EXTEND)
  ),
  CLASS_CODE_BLOCK
).name(Token.CLASS_DECLARATION);

// @ts-ignore
_STATEMENTS = _STATEMENTS.OR(
  CONCAT(
    OPTIONAL(
      OR(
        CONCAT(TRUE_STATEMENTS, SEMICOLON),
        IF_STATEMENT,
        FOR_STATEMENT,
        WHILE_STATEMENT,
        DO_WHILE_STATEMENT,
        TRY_STATEMENT,
        FUNCTION_STATEMENT,
        RETURN_STATEMENT,
        ITERATIVE_CONTROL_STATEMENT,
        SWITCH_STATEMENT,
        RAISE_STATEMENT,
        CODE_BLOCK,
        CLASS_DECLARATION
      )
    ),
    OPTIONAL(CONCAT(WHITESPACE, COMMENT))
  )
);

export const SWISS = LIST_OF_STATEMENTS;
